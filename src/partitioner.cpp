#include "globals.h"
#include "partitioner.h"
#include "display.h"
#include "mykeyboard.h"


// Using "buff[4096]" to store and write the partitions

const uint8_t doom[160] = { // 6Mb app partition
    0xAA, 0x50, 0x01, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x6E, 0x76, 0x73, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x01, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x6F, 0x74, 0x61, 0x64,
    0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x00, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x61, 0x70, 0x70, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x00, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x06, 0x00, 0x61, 0x70, 0x70, 0x31,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xEB, 0xEB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x32, 0x00, 0x6E, 0x04, 0xD7, 0x54, 0x3A, 0x63, 0xC1, 0xE9, 0x96, 0xDC, 0x64, 0xC6, 0xBC, 0x58
};

const uint8_t def_part[192] PROGMEM = { // default partition scheme(App, FAT and SPIFFS)
    0xAA, 0x50, 0x01, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x6E, 0x76, 0x73, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x01, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x6F, 0x74, 0x61, 0x64,
    0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x00, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x74, 0x65, 0x73, 0x74,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x00, 0x10, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x26, 0x00, 0x61, 0x70, 0x70, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x01, 0x82, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 0x03, 0x00, 0x73, 0x70, 0x69, 0x66,
    0x66, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xEB, 0xEB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x51, 0x6E, 0xC4, 0x73, 0x0A, 0xF0, 0xB4, 0x00, 0xEE, 0x2F, 0xB5, 0xFF, 0xEC, 0x71, 0x7E, 0x27,
};


const uint8_t uiflow2[224] PROGMEM = { // uiflow partition scheme, APP, sys(FAT) and vfs(FAT)
    0xAA, 0x50, 0x01, 0x02, 0x00, 0x90, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x6E, 0x76, 0x73, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x01, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x6F, 0x74, 0x61, 0x64,
    0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x00, 0x20, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x61, 0x70, 0x70, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x00, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x37, 0x00, 0x61, 0x70, 0x70, 0x31,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x01, 0x81, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x10, 0x00, 0x73, 0x79, 0x73, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAA, 0x50, 0x01, 0x81, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x19, 0x00, 0x76, 0x66, 0x73, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xEB, 0xEB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xD1, 0xD5, 0x8F, 0xC3, 0xB0, 0x82, 0x0F, 0x40, 0xD3, 0x17, 0xD4, 0x77, 0xE3, 0x4B, 0x74, 0xA6,
};

void resetBuffer() {
    for(int i=0; i<sizeof(buff); i++) buff[i] = 0xFF;
}

bool partitionSetter (const uint8_t* scheme) {
    // Prepare the desired partition scheme Data

    memcpy(buff,scheme,sizeof(scheme));

    esp_err_t err;
    // erase old partition table
    err = spi_flash_erase_range(0x8000, 0x1000);
    if(err != ESP_OK) return false;

    // flash new partition table
    err = spi_flash_write(0x8000, buff, sizeof(buff));
    if(err != ESP_OK) return false;

    return true;
}

void partitioner() {
    int partition = 0;
    const uint8_t* data = nullptr;
    options = {
        {"Default", [&](){ partition = 0; }},
        {"Doom", [&](){ partition = 1; }},
        {"UiFlow2", [&](){ partition = 2; }},
    };
    delay(200);
    loopOptions(options);
    displayRedStripe("Preparing");
    switch(partition) {
        case 0: data = def_part;
                break;
        case 1: data = doom;
                break;
        case 2: data = uiflow2;
                break;
        default: data = def_part;
    }

    if(!partitionSetter(data)) {
        Serial.println("Error when running partitionSetter function");
        displayRedStripe("Partitioning Error");
        while(!checkSelPress()) yield();
    }

    displayRedStripe("Hard Restart needed");
    while(!checkSelPress()) yield();
    while(checkSelPress()) yield();
    displayRedStripe("Turn OFF and ON");
    while(!checkSelPress()) yield();
    while(checkSelPress()) yield();
}

void partList() {
      // Obtemos a lista de partições
  const esp_partition_t* partition;
  esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_ANY, ESP_PARTITION_SUBTYPE_ANY, NULL);

  if (it != NULL) {
    Serial.println("Partições encontradas:");
    String txt="";
    while (it != NULL) {
      partition = esp_partition_get(it);
      Serial.print("Nome: ");
      Serial.println(partition->label);
      Serial.print("Tipo: ");
      Serial.print(partition->type, HEX);
      Serial.print(" (");
      switch (partition->type) {
        case ESP_PARTITION_TYPE_APP:
          Serial.print("Aplicação");
          break;
        case ESP_PARTITION_TYPE_DATA:
          Serial.print("Dados");
          break;
        default:
          Serial.print("Desconhecido");
          break;
      }
      Serial.println(")");
      Serial.print("Subtipo: ");
      Serial.print(partition->subtype, HEX);
      Serial.print(" (");
      switch (partition->subtype) {
        case ESP_PARTITION_SUBTYPE_APP_FACTORY:
          Serial.print("Fábrica");
          break;
        case ESP_PARTITION_SUBTYPE_APP_OTA_0:
        case ESP_PARTITION_SUBTYPE_APP_OTA_1:
          Serial.print("OTA");
          txt+="OTA,";
          break;
        case ESP_PARTITION_SUBTYPE_APP_TEST:
          Serial.print("Teste");
          break;
        case ESP_PARTITION_SUBTYPE_DATA_PHY:
          Serial.print("PHY");
          break;
        case ESP_PARTITION_SUBTYPE_DATA_NVS:
          Serial.print("NVS");
          break;
        case ESP_PARTITION_SUBTYPE_DATA_COREDUMP:
          Serial.print("Core Dump");
          break;
        case ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD:
          Serial.print("ESP HTTPD");
          break;
        case ESP_PARTITION_SUBTYPE_DATA_FAT:
          Serial.print("FAT");
          txt+="FAT,";
          break;
        case ESP_PARTITION_SUBTYPE_DATA_SPIFFS:
          Serial.print("SPIFFS");
          txt+="SPIFFs";
          break;
        default:
          Serial.print("Desconhecido");
          break;
      }
      Serial.println(")");
      Serial.print("Endereço: 0x");
      Serial.println(partition->address, HEX);
      Serial.print("Tamanho: 0x");
      Serial.println(partition->size, HEX);
      Serial.println();
      
      it = esp_partition_next(it);
    }
    esp_partition_iterator_release(it);

    displayRedStripe(txt);
    while(!checkSelPress()) yield();
    while(checkSelPress()) yield();    
  } else {
    Serial.println("Nenhuma partição encontrada.");
  }
  

}